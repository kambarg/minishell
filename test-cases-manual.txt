===Subject of the minishell says ========
==='take bash as a reference'============
$ echo $SHELL
/bin/bash
if the output is not bash than you need to switch
$ bash
$ which bash
This usually returns /bin/bash or /usr/bin/bash.

Note:
If you execute bash (/usr/bin/bash) in minishell it 
forks a child process. This child process takes 
over the terminal, ie terminal is bash instead of 
minishell. If exit or ctrl+D, bash exits and terminal 
returns to minishell.  


===subject requirements=================
===ok===
===Display a prompt when waiting for a new command:
~$ ./minishell 
minishell$

===ok===
===Have a working history:
minishell$ history
returns the list of commands entered in terminal


===fail?===
===!Cannot check on Mac (no sudo rights to change /usr/bin/ls)
===Search and launch the right executable 
(based on the PATH variable or using a
relative or an absolute path)
$ which ls
/usr/bin/ls
$ ls
# files and directories listed
$ /usr/bin/ls
# files and directories listed

$ ./my_program
./my_program: No such file or directory

$ nonexistent
nonexistent: command not found

===fail===
$ sudo mv /usr/bin/ls /usr/bin/ls_backup
$ ls
bash: /usr/bin/ls: No such file or directory
minishell$ ls
minishell: ls: command not found
Error message in minishell differs from the bash error message.

===?===
===Signal handler =========================
= Avoid using more than one global variable to indicate 
a received signal.
= signal handler will not access your
main data structures

===ok===
===Single quote==============================
Handle â€™ (single quote) which should prevent the shell 
from interpreting the metacharacters in the quoted sequence.

$ echo '$HOME'
$HOME
$ echo $HOME
/home/goha
$ echo "$HOME"
/home/goha
$ echo '*.txt'
*.txt

=== out of scope of subject (unclosed quotes) ====
$ echo 'can't'
> '
cant
minishell$ echo 'can't'
minishell: syntax error: unclosed quotes

$ echo 'can'\''t'
can't
minishell$ echo 'can'\''t'
minishell: syntax error: unclosed quote


===ok===
===double quotes=================================
Handle " (double quote) which should prevent the shell 
from interpreting the metacharacters in the quoted 
sequence except for $ (dollar sign).

$ echo $HOME
/home/<user_name>
$ echo "$HOME"
/home/<user_name>

===ok===
===environment variables=======================
Handle environment variables ($ followed by a sequence 
of characters) which should expand to their values.
$ env
<will print all exported environment variables>
HOME=/home/goha
USER=goha
PATH=/usr/local/bin:/usr/bin:/bin
...
$ env | grep -E 'PWD|OLDPWD|USER|HOME'
<will print main env variables values>

Test OLDPWD:
echo $PWD      # Should show current directory
echo $OLDPWD   # Should show parent shell's OLDPWD
cd /tmp
echo $OLDPWD   # Should show previous directory
echo $PWD      # Should show /tmp
cd -           # Should go back to previous directory
echo $PWD      # Should show original directory

$ echo $NOTSET

$ export EMPTY=
$ echo $EMPTY

$ echo "User is $USER"
User is goha
$ echo $
$
$ echo test$
test$
$  export A=bye B=tester
$ echo $A $B
bye tester
$ export TEMPVAR=hello
$ unset TEMPVAR
$ echo $TEMPVAR

$ export USER=goha
$ echo "Hi, '$USER', welcome!"
Hi, 'goha', welcome!



===Redirections==========================
==ok==
$ cat test.txt | grep "hello" < test2.txt
zsh: no such file or directory: test2.txt
cat: test.txt: No such file or directory

== error message doubled =================
grep "t" < test.txt
zsh: no such file or directory: test.txt

minishell$ grep "t" < test.txt
test.txt:No such file or directory
minishell: test.txt: No such file or directory

== error message doubled====================
ls | cat < test2.txt
hahaha

minishell$ ls | cat < test2.txt
test2.txt:No such file or directory
minishell: test2.txt: No such file or directory


==ok==
cat <<END >test.txt
heredoc> line 1
heredoc> line 2
heredoc> END

==ok==
$ < test2.txt | ls
test.txt        test2.txt

== error message duplicated ===================
$ cat > t.txt -e < f.txt | < t.txt
bash: f.txt: No such file or directory
t.txt is created

minishell$ cat > t.txt -e < f.txt | < t.txt
f.txt:No such file or directory
minishell: f.txt: No such file or directory


===Edge cases=========================
==ok==
$        echo      hello     world    
hello world

==ok==
$ echo ""


== 

==ok==
$ > test2.txt < test.txt
zsh: no such file or directory: test.txt
== we need write printf to print_error


gkambarb@lab1r3s6 tmp % ls -l
total 0
-rw-r--r--  1 gkambarb  2024_abu-dhabi  0 Mar 24 18:21 test2.txt
== No message "no such file.."
== test2.txt was not created
== if test2.txt exists and has text, text.txt doesn't exist, input line has to overwringt test2.txt content and make it empty


==ok ==
< jfkdg > file.txt
bash: djghkjs: No such file or directory
== No message "No such file..."


==ok ===
>file.txt < dsghfkfjs
bash: dsghfkfjs: No such file or directory
== No message "No such file.."
== file.txt was not created


==ok==
$ < file2.txt | ls
bash: file2.txt: No such file or directory
file.txt	test-cases.txt	test.txt	test2.tx
==No message "No such file.."

==ok==
$ |
bash: syntax error near unexpected token `|'
$ echo $?
258
or 
2
== !!! We have to check which code is correct
== Not correct exit code


== ok ==
$ echo "hahaha" > test2.txt
$ ls | cat < test2.txt
hahaha

== If user deletes ls executable file ==
After deleting ls executable file (ie /usr/bin/ls)
the command
$ ls
hash: ls: command not found

In minishell the program will 
fail because executable is being executed with execve or similar function.  


==Heredoc=================
===ok===

$ cat << TEXT
> One
> Two
> Three
> TEXT

===ok===
$ cat << TEXT > out.txt
> One
> Two
> Three
TEXT
$ cat out.txt
> One
> Two
> Three
# There should be file out.txt. with heredoc text written in it


=== ok ===
command:
$ cat <<EOF1 > out.txt | cat <<EOF2
> 1
> 2
> 3
> EOF1
> AA
> BB
> CC
> EOF2

result:
In the output it is
AA
BB
CC
in the out.txt. file it is
1
2
3

== ok ==
$ cat << eof | grep b | wc -l
> a
> b 
> c 
> eof

== ok ==
$ cat << eof > out.txt | cat << text
> a 
> b 
> c 
> eof 
> hello 
> bye 
> text