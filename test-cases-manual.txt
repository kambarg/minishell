===Subject of the minishell says ========
==='take bash as a reference'============
$ echo $SHELL
/bin/bash
if the output is not bash than you need to switch
$ bash
$ which bash
This usually returns /bin/bash or /usr/bin/bash.

Note:
If you execute bash (/usr/bin/bash) in minishell it 
forks a child process. This child process takes 
over the terminal, ie terminal is bash instead of 
minishell. If exit or ctrl+D, bash exits and terminal 
returns to minishell.  


===subject requirements=================
===ok===
===Display a prompt when waiting for a new command:
~$ ./minishell 
minishell$

===ok===
===Have a working history:
In minishell 'history' command won't work if you don't implement
a function as it is built-in command. But readline/history.h 
library has add_history, clear_history functions that you can use 
to implement history working history functionality (using arrow keys).

===out of scope of subject (history is not in built-in list)=== 
minishell$ history
minishell: history: command not found


===fail?===
===!Cannot check on Mac (no sudo rights to change /usr/bin/ls)
===Search and launch the right executable 
(based on the PATH variable or using a
relative or an absolute path)
$ which ls
/usr/bin/ls
$ ls
# files and directories listed
$ /usr/bin/ls
# files and directories listed

$ ./my_program
./my_program: No such file or directory

$ nonexistent
nonexistent: command not found

===fail===
$ sudo mv /usr/bin/ls /usr/bin/ls_backup
$ ls
bash: /usr/bin/ls: No such file or directory
minishell$ ls
minishell: ls: command not found
Error message in minishell differs from the bash error message.

===?===
===Signal handler =========================
= Avoid using more than one global variable to indicate 
a received signal.
= signal handler will not access your
main data structures

===ok===
===Single quote==============================
Handle â€™ (single quote) which should prevent the shell 
from interpreting the metacharacters in the quoted sequence.

$ echo '$HOME'
$HOME
$ echo $HOME
/home/goha
$ echo "$HOME"
/home/goha
$ echo '*.txt'
*.txt

===out of scope of subject (unclosed quotes)===
$ echo 'can't'
> '
cant
minishell$ echo 'can't'
minishell: syntax error: unclosed quotes

$ echo 'can'\''t'
can't
minishell$ echo 'can'\''t'
minishell: syntax error: unclosed quote


===ok===
===double quotes=================================
Handle " (double quote) which should prevent the shell 
from interpreting the metacharacters in the quoted 
sequence except for $ (dollar sign).

$ echo $HOME
/home/<user_name>
$ echo "$HOME"
/home/<user_name>

===ok===
===environment variables=======================
Handle environment variables ($ followed by a sequence 
of characters) which should expand to their values.
$ env
<will print all exported environment variables>
HOME=/home/goha
USER=goha
PATH=/usr/local/bin:/usr/bin:/bin
...
$ env | grep -E 'PWD|OLDPWD|USER|HOME'
<will print main env variables values>

Test OLDPWD:
echo $PWD      # Should show current directory
echo $OLDPWD   # Should show parent shell's OLDPWD
cd /tmp
echo $OLDPWD   # Should show previous directory
echo $PWD      # Should show /tmp
cd -           # Should go back to previous directory
echo $PWD      # Should show original directory

$ echo $NOTSET

$ export EMPTY=
$ echo $EMPTY

$ echo "User is $USER"
User is goha
$ echo $
$
$ echo test$
test$
$  export A=bye B=tester
$ echo $A $B
bye tester
$ export TEMPVAR=hello
$ unset TEMPVAR
$ echo $TEMPVAR

$ export USER=goha
$ echo "Hi, '$USER', welcome"
Hi, 'goha', welcome


===???error===
=== quotes inside quotes=============
minishell$ echo $HOME
/Users/gkambarb
minishell$ echo "$HOME"
/Users/gkambarb
minishell$ 
minishell$ echo " '$HOME' " 
 '/Users/gkambarb'           # has to be  "$HOME"
minishell$ 
minishell$ echo  '$HOME' 
$HOME
minishell$ echo  ' "$HOME" ' 
 "$HOME"                     # has to be  '/Users/gkambarb'



===Redirections==========================
==ok==
$ cat test.txt | grep "hello" < test2.txt
minishell: test2.txt: No such file or directory
cat: test.txt: No such file or directory

===ok===
grep "t" < test.txt
minishell: test.txt: No such file or directory

===ok===
$ ls | cat < test2.txt
minishell: test2.txt: No such file or directory

==ok===
cat <<END >test.txt
heredoc> line 1
heredoc> line 2
heredoc> END

==ok===
$ < test.txt | ls
test.txt        test2.txt

===ok===
$ cat > t.txt -e < f.txt | < t.txt
bash: f.txt: No such file or directory
t.txt is created


===Edge cases=========================
===ok===
$        echo      hello     world    
hello world

===ok===
$ echo ""

===ok===
$ |
bash: syntax error near unexpected token `|'
$ echo $?
258

===ok===
$ ls -l
total 0
$ > test2.txt < test.txt
minishell: test.txt: No such file or directory
$ cat test2.txt

If test2.txt does not exist, it should be created and be empty.
If test2.txt exists and has text, text.txt doesn't exist, input line has to overwringt test2.txt content and make it empty.

===ok===
< jfkdg > file.txt
minishell: jfkdg: No such file or directory

===ok===
>file.txt < dsghfkfjs
minishell: dsghfkfjs: No such file or directory

file.txt was created and empty.

===ok===
$ < file2.txt | ls
bash: file2.txt: No such file or directory
file.txt	test-cases.txt	test.txt	test2.tx

===ok===
$ echo "hahaha" > test2.txt
$ ls | cat < test2.txt
hahaha



===Heredoc=================
===ok===
$ cat << TEXT
> One
> Two
> Three
> TEXT

===ok===
$ cat << TEXT > out.txt
> One
> Two
> Three
TEXT
result:
$ cat out.txt
> One
> Two
> Three
# There should be file out.txt. with heredoc text written in it


===ok===
command:
$ cat <<EOF1 > out.txt | cat <<EOF2
> 1
> 2
> 3
> EOF1
> AA
> BB
> CC
> EOF2
result:
In the output it is
AA
BB
CC
in the out.txt. file it is
1
2
3

===ok===
$ cat << eof | grep b | wc -l
> a
> b 
> c 
> eof
result: 
 1 is printed to the output


===ok===
$ cat << eof > out.txt | cat << text
> a 
> b 
> c 
> eof 
> hello 
> bye 
> text
result:
in the standard output 
hello
bye
$ cat out.txt 
a
b
c



===Random=========
cat testing/out.txt | grep "$USER" | wc -l
